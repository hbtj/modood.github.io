<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>Tendermint</title>
  <style type="text/css">
    body {
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  color: #222;
  font-size: 100%;
}

.slide {
  position: absolute;
  top: 0; bottom: 0;
  left: 0; right: 0;
  background-color: #f7f7f7;
}

.slide-content {
  width: 800px;
  height: 600px;
  overflow: hidden;
  margin: 80px auto 0 auto;
  padding: 30px;

  font-weight: 200;
  font-size: 200%;
  line-height: 1.375;
}

.controls {
  position: absolute;
  bottom: 20px;
  left: 20px;
}

.arrow {
  width: 0; height: 0;
  border: 30px solid #333;
  float: left;
  margin-right: 30px;

  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.prev {
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-left-color: transparent;

  border-left-width: 0;
  border-right-width: 50px;
}

.next {
  border-top-color: transparent;
  border-bottom-color: transparent;
  border-right-color: transparent;

  border-left-width: 50px;
  border-right-width: 0;
}

.prev:hover {
  border-right-color: #888;
  cursor: pointer;
}

.next:hover {
  border-left-color: #888;
  cursor: pointer;
}

h1 {
  font-size: 300%;
  line-height: 1.2;
  text-align: center;
  margin: 170px 0 0;
}

h2 {
  font-size: 100%;
  line-height: 1.2;
  margin: 5px 0;
  text-align: center;
  font-weight: 200;
}

h3 {
  font-size: 140%;
  line-height: 1.2;
  border-bottom: 1px solid #aaa;
  margin: 0;
  padding-bottom: 15px;
}

ul {
  padding: 20px 0 0 60px;
  font-weight: 200;
  line-height: 1.375;
}

.author h1 {
  font-size: 170%;
  font-weight: 200;
  text-align: center;
  margin-bottom: 30px;
}

.author h3 {
  font-weight: 100;
  text-align: center;
  font-size: 95%;
  border: none;
}

a {
  text-decoration: none;
  color: #44a4dd;
}

a:hover {
  color: #66b5ff;
}

pre {
  font-size: 60%;
  line-height: 1.3;
}

.progress {
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 3px;
  z-index: 1;
}

.progress-bar {
  width: 0%;
  height: 3px;
  background-color: #b4b4b4;

  -webkit-transition: width 0.05s ease-out;
  -moz-transition: width 0.05s ease-out;
  -o-transition: width 0.05s ease-out;
  transition: width 0.05s ease-out;
}

.hidden {
  display: none;
}

@media (max-width: 850px) {

  body {
    font-size: 70%;
  }

  .slide-content {
    width: auto;
  }

  img {
    width: 100%;
  }

  h1 {
    margin-top: 120px;
  }

  .prev, .prev:hover {
    border-right-color: rgba(135, 135, 135, 0.5);
  }

  .next, .next:hover {
    border-left-color: rgba(135, 135, 135, 0.5);
  }
}

@media (max-width: 480px) {
  body {
    font-size: 50%;
    overflow: hidden;
  }

  .slide-content {
    padding: 10px;
    margin-top: 10px;
    height: 340px;
  }

  h1 {
    margin-top: 50px;
  }

  ul {
    padding-left: 25px;
  }
}

@media print {
  * {
    -webkit-print-color-adjust: exact;
  }

  @page {
    size: letter;
  }

  .hidden {
    display: inline;
  }

  html {
    width: 100%;
    height: 100%;
    overflow: visible;
  }

  body {
    margin: 0 auto !important;
    border: 0;
    padding: 0;
    float: none !important;
    overflow: visible;
    background: none !important;
    font-size: 52%;
  }

  .progress, .controls {
    display: none;
  }

  .slide {
    position: static;
  }

  .slide-content {
    border: 1px solid #222;
    margin-top: 0;
    margin-bottom: 40px;
    height: 3.5in;
    overflow: visible;
  }

  .slide:nth-child(even) {
    /* 2 slides per page */
    page-break-before: always;
  }
}

/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}


  </style>
</head>
<body>
    <div class="progress">
    <div class="progress-bar"></div>
  </div>

  <div class="slide" id="slide-1">
    <section class="slide-content"><h1 id="tendermint">Tendermint</h1>
<p><br/><center>Warner Ma</center></p>
</section>
  </div>
  <div class="slide hidden" id="slide-2">
    <section class="slide-content"><h3 id="what-is-tendermint-">What is Tendermint?</h3>
<p>Tendermint is software for <u><strong>securely</strong></u> and <u><strong>consistently</strong></u>
replicating an application on many machines.</p>
<p><strong>securely</strong></p>
<pre><code>works even if up to 1/3 of machines fail in arbitrary ways
</code></pre><p><strong>consistently</strong></p>
<pre><code>every non-faulty machine sees the same transaction log and computes the same state
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-3">
    <section class="slide-content"><h3 id="tendermint-vs-zk-etcd-consul">Tendermint vs ZK, etcd, consul</h3>
<p><strong>zookeeper, etcd, consul</strong></p>
<pre><code>1.  non-BFT: Zookeeper Atomic Broadcast(Paxos), Raft
    can tolerate crash failures in up to 1/2 of the machines,
    but even a single Byzantine fault can destroy the system
2.  focused around providing basic services to distributed systems:
    kv store, dynamic configuration, service discovery,
    locking, leader-election, and so on.
</code></pre><p><strong>tendermint</strong></p>
<pre><code>1.  BFT: Byzantine Fault Tolerant
    can only tolerate up to a 1/3 of failures,
    but those failures can include arbitrary behaviour
2.  focuses on arbitrary state machine replication
    It does not specify a particular application.
    so developers can build the application logic that&#39;s right for them:
    from key-value store to cryptocurrency to e-voting platform and beyond.
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-4">
    <section class="slide-content"><h3 id="tendermint-vs-bitcoin-ethereum">Tendermint vs Bitcoin, Ethereum</h3>
<p><strong>bitcoin, ethereum</strong></p>
<pre><code>1.  cryptocurrencies
2.  Proof of Work
</code></pre><p><strong>tendermint</strong></p>
<pre><code>A general purpose blockchain consensus engine.

It can be used as a plug-and-play replacement for the consensus engines
of other blockchain software
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-5">
    <section class="slide-content"><h3 id="tendermint-vs-bitcoin-ethereum">Tendermint vs Bitcoin, Ethereum</h3>
<p><strong><a href="https://github.com/cosmos/ethermint">cosmos/ethermint</a></strong></p>
<pre><code>Run Ethereum as a ABCI application using Tendermint consensus
</code></pre><p><strong><a href="https://github.com/hyperledger/burrow">hyperledger/burrow</a></strong></p>
<pre><code>An implementation of the Ethereum Virtual Machine and Ethereum transaction mechanics,
with additional features for a name-registry, permissions, and native contracts,
and an alternative blockchain API.

It uses Tendermint as its consensus engine, and provides a particular application state.
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-6">
    <section class="slide-content"><h3 id="abci">ABCI</h3>
<p><strong>ABCI: Application BlockChain Interface</strong></p>
<pre><code>*   Decouple the consensus engine and P2P layers
*   Abstracting away the details of the particular blockchain application
    to an interface

Thus we have an interface, the Application BlockChain Interface (ABCI),
and its primary implementation, the Tendermint Socket Protocol (TSP, or Teaspoon).

Message Types: DeliverTx, CheckTx, Commit
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-7">
    <section class="slide-content"><h3 id="abci">ABCI</h3>
<p><strong>communicate with the application</strong></p>
<pre><code>Tendermint Core (the &quot;consensus engine&quot;) communicates with the application
via a socket protocol that satisfies the ABCI.

Tendermint acts as an ABCI client with respect to the application and
maintains 3 connections: mempool, consensus and query.

*   one for the validation of transactions when broadcasting in the mempool
*   one for the consensus engine to run block proposals
*   one for querying the application state

application: application process
tendermint core: consensus process
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-8">
    <section class="slide-content"><h3 id="abci">ABCI</h3>
<p><img src="images/abci.png" style="width: 80%; height: auto; max-width: 100%; display: block; margin: 0 auto;"/></p>
</section>
  </div>
  <div class="slide hidden" id="slide-9">
    <section class="slide-content"><h3 id="listening">Listening</h3>
<p><strong>default</strong></p>
<pre><code>26656     the listening address of the tendermint peer
26657     the listening address of the RPC server
26658     the socket address of the abci application
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-10">
    <section class="slide-content"><h3 id="peers">Peers</h3>
<p><strong>about</strong></p>
<pre><code>p2p Provides an abstraction around peer-to-peer communication.

peer exchange protocol (PeX)

*  Seed
*  Persistent Peer

*  Validator
*  Non-Validator
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-11">
    <section class="slide-content"><h3 id="rpc-server">RPC server</h3>
<p><strong>about</strong></p>
<pre><code>Tendermint supports the following RPC protocols:

*   URI over HTTP
*   JSONRPC over HTTP
*   JSONRPC over websockets

Broadcast API:

/broadcast_tx_async     will return right away
                        without waiting to hear if the transaction is even valid
/broadcast_tx_sync      will return with the result
                        of running the transaction through `CheckTx`
/broadcast_tx_commit    will wait until the transaction is committed in a block
                        or until some timeout is reached

Documentation: https://tendermint.com/rpc/
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-12">
    <section class="slide-content"><h3 id="rpc-server">RPC server</h3>
<p><strong>subscribing to events via websocket</strong></p>
<pre><code>const (
    EventCompleteProposal    = &quot;CompleteProposal&quot;
    EventLock                = &quot;Lock&quot;
    EventNewBlock            = &quot;NewBlock&quot;
    EventNewBlockHeader      = &quot;NewBlockHeader&quot;
    EventNewRound            = &quot;NewRound&quot;
    EventNewRoundStep        = &quot;NewRoundStep&quot;
    EventPolka               = &quot;Polka&quot;
    EventProposalHeartbeat   = &quot;ProposalHeartbeat&quot;
    EventRelock              = &quot;Relock&quot;
    EventTimeoutPropose      = &quot;TimeoutPropose&quot;
    EventTimeoutWait         = &quot;TimeoutWait&quot;
    EventTx                  = &quot;Tx&quot;
    EventUnlock              = &quot;Unlock&quot;
    EventValidatorSetUpdates = &quot;ValidatorSetUpdates&quot;
    EventVote                = &quot;Vote&quot;
)
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-13">
    <section class="slide-content"><h3 id="mempool">Mempool</h3>
<p><strong>about</strong></p>
<pre><code>mempool module handles all incoming transactions,
whenever they are coming from peers or the application.

A tx passed `CheckTx` (ie. was accepted into the mempool),


option: mempool.recheck = true

After every block, Tendermint rechecks every transaction left in the mempool
to see if transactions committed in that block affected the application state,
so some of the transactions left may become invalid.
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-14">
    <section class="slide-content"><h3 id="consensus">Consensus</h3>
<p><strong>standard block creation cycle</strong></p>
<pre><code>1.  enter new round
2.  enter `propose`
    signed proposal
    received complete proposal block
3.  enter `prevote`
    signed and pushed vote
    added to prevote
4.  enter `precommit`
    signed and pushed vote
    added to precommit
5.  enter `commit`
    executed block
    committed state
    recheck txs

blocks are produced regularly, even if there are no transactions.
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-15">
    <section class="slide-content"><h3 id="consensus">Consensus</h3>
<p><img src="images/consensus.png" style="width: 100%; height: auto; max-width: 100%; display: block; margin: 0 auto;"/></p>
</section>
  </div>
  <div class="slide hidden" id="slide-16">
    <section class="slide-content"><h3 id="wal">WAL</h3>
<p><strong>WAL: Write Ahead Logs</strong></p>
<pre><code>wal: for ensuring data integrity
replay: to replay blocks and messages on recovery from a crash

tendermint uses write ahead logs for:

*   the mempool (mempool.wal): writes all incoming txs before running `CheckTx`
*   the consensus (cs.wal): writes all consensus messages
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-17">
    <section class="slide-content"><h3 id="fast-sync">Fast Sync</h3>
<p><del>run the real-time consensus gossip protocol</del></p>
<pre><code>option: fast_sync = true

`fast-sync` mode is enabled by default

1.  just download blocks
2.  check the merkle tree of validators
3.  the node is considered `caught up` if it has at least one peer and
    it&#39;s height is at least as high as the max reported peer height
4.  once `caught up`, the daemon will switch out of fast sync and
    into the normal consensus mode
5.  if we&#39;re lagging sufficiently, we should go back to fast syncing
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-18">
    <section class="slide-content"><h3 id="configuration">Configuration</h3>
<p><strong><a href="https://tendermint.com/docs/tendermint-core/running-in-production.html#configuration-parameters">config.toml</a></strong></p>
<pre><code>▾ config/                       +---------------------+
    config.toml --------------&gt; |   base              |
    genesis.json                |   rpc               |
    node_key.json               |   p2p               |
    priv_validator.json         |   mempool           |
                                |   consensus         |
▾ data/                         |   tx_index          |
    blockstore.db               |   instrumentation   |
    evidence.db                 +---------------------+
    state.db
    tx_index.db
    cs.wal
    mempool.wal
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-19">
    <section class="slide-content"><h3 id="tools">Tools</h3>
<p><strong>tools for working with tendermint</strong></p>
<pre><code>*   tools/tm-bench
*   tools/tm-monitor
*   scripts/wal2json
*   scripts/json2wal
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-20">
    <section class="slide-content"><h3 id="miscellaneous">Miscellaneous</h3>
<p><strong>non-determinism</strong></p>
<pre><code>*   random number generators (without deterministic seeding)
*   race conditions on threads (or avoiding threads altogether)
*   the system clock
*   uninitialized memory (in unsafe programming languages like C or C++)
*   floating point arithmetic
*   language features that are random (e.g. map iteration in Go)
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-21">
    <section class="slide-content"><h3 id="workflow">Workflow</h3>
<pre><code>
1.  create three connections (mempool, consensus and query) to the application
2.  tendermint core and the application perform a handshake
3.  start a few more things like the event switch, reactors,
    and perform UPNP discover in order to detect the IP address
4.  replay all the messages from the wal
5.  &quot;started node&quot; message signals that everything is ready for work
6.  next follows a standard block creation cycle, where we enter a new round,
    1) propose a block,
    2) receive more than 2/3 of prevotes,
    3) then precommits
    4) finally have a chance to commit a block
</code></pre></section>
  </div>
  <div class="slide hidden" id="slide-22">
    <section class="slide-content"><h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tendermint/tendermint">github - tendermint</a></li>
<li><a href="https://tendermint.com/docs/">tendermint core docs</a></li>
<li><a href="https://tendermint.com/rpc/">tendermint rpc reference</a></li>
</ul>
</section>
  </div>
  <div class="slide hidden" id="slide-23">
    <section class="slide-content"><h1 id="thanks">Thanks</h1>
<p><br/><center>2018.09.26</center></p>
</section>
  </div>
  <div class="slide hidden author-slide" id="slide-24">
    <section class="slide-content"><div class="author">
  <h1 class="name">modood</h1>
    <h3 class="url">
      <a href="https://github.com/modood">https://github.com/modood</a>
    </h3>
</div>
</section>
  </div>

  <div class="controls">
    <div class="arrow prev"></div>
    <div class="arrow next"></div>
  </div>


  <script type="text/javascript">
    /**
 * Returns the current page number of the presentation.
 */
function currentPosition() {
  return parseInt(document.querySelector('.slide:not(.hidden)').id.slice(6));
}


/**
 * Navigates forward n pages
 * If n is negative, we will navigate in reverse
 */
function navigate(n) {
  var position = currentPosition();
  var numSlides = document.getElementsByClassName('slide').length;

  /* Positions are 1-indexed, so we need to add and subtract 1 */
  var nextPosition = (position - 1 + n) % numSlides + 1;

  /* Normalize nextPosition in-case of a negative modulo result */
  nextPosition = (nextPosition - 1 + numSlides) % numSlides + 1;

  document.getElementById('slide-' + position).classList.add('hidden');
  document.getElementById('slide-' + nextPosition).classList.remove('hidden');

  updateProgress();
  updateURL();
  updateTabIndex();
}


/**
 * Updates the current URL to include a hashtag of the current page number.
 */
function updateURL() {
  try {
    window.history.replaceState({} , null, '#' + currentPosition());
  } catch (e) {
    window.location.hash = currentPosition();
  }
}


/**
 * Sets the progress indicator.
 */
function updateProgress() {
  var progressBar = document.querySelector('.progress-bar');

  if (progressBar !== null) {
    var numSlides = document.getElementsByClassName('slide').length;
    var position = currentPosition() - 1;
    var percent = (numSlides === 1) ? 100 : 100 * position / (numSlides - 1);
    progressBar.style.width = percent.toString() + '%';
  }
}


/**
 * Removes tabindex property from all links on the current slide, sets
 * tabindex = -1 for all links on other slides. Prevents slides from appearing
 * out of control.
 */
function updateTabIndex() {
  var allLinks = document.querySelectorAll('.slide a');
  var position = currentPosition();
  var currentPageLinks = document.getElementById('slide-' + position).querySelectorAll('a');
  var i;

  for (i = 0; i < allLinks.length; i++) {
    allLinks[i].setAttribute('tabindex', -1);
  }

  for (i = 0; i < currentPageLinks.length; i++) {
    currentPageLinks[i].removeAttribute('tabindex');
  }
}

/**
 * Determines whether or not we are currently in full screen mode
 */
function isFullScreen() {
  return document.fullscreenElement ||
         document.mozFullScreenElement ||
         document.webkitFullscreenElement ||
         document.msFullscreenElement;
}

/**
 * Toggle fullScreen mode on document element.
 * Works on chrome (>= 15), firefox (>= 9), ie (>= 11), opera(>= 12.1), safari (>= 5).
 */
function toggleFullScreen() {
  /* Convenient renames */
  var docElem = document.documentElement;
  var doc = document;

  docElem.requestFullscreen =
      docElem.requestFullscreen ||
      docElem.msRequestFullscreen ||
      docElem.mozRequestFullScreen ||
      docElem.webkitRequestFullscreen.bind(docElem, Element.ALLOW_KEYBOARD_INPUT);

  doc.exitFullscreen =
      doc.exitFullscreen ||
      doc.msExitFullscreen ||
      doc.mozCancelFullScreen ||
      doc.webkitExitFullscreen;

  isFullScreen() ? doc.exitFullscreen() : docElem.requestFullscreen();
}

document.addEventListener('DOMContentLoaded', function () {
  // Update the tabindex to prevent weird slide transitioning
  updateTabIndex();

  // If the location hash specifies a page number, go to it.
  var page = window.location.hash.slice(1);
  if (page) {
    navigate(parseInt(page) - 1);
  }

  document.onkeydown = function (e) {
    var kc = e.keyCode;

    // left, down, H, J, backspace, PgUp - BACK
    // up, right, K, L, space, PgDn - FORWARD
    // enter - FULLSCREEN
    if (kc === 37 || kc === 40 || kc === 8 || kc === 72 || kc === 74 || kc === 33) {
      navigate(-1);
    } else if (kc === 38 || kc === 39 || kc === 32 || kc === 75 || kc === 76 || kc === 34) {
      navigate(1);
    } else if (kc === 13) {
      toggleFullScreen();
    }
  };

  if (document.querySelector('.next') && document.querySelector('.prev')) {
    document.querySelector('.next').onclick = function (e) {
      e.preventDefault();
      navigate(1);
    };

    document.querySelector('.prev').onclick = function (e) {
      e.preventDefault();
      navigate(-1);
    };
  }
});


  </script>
</body>
</html>
