『JavaScript 化整为零』之引用
=============================

Table of contents
-----------------

*   [前言](#前言)
*   [基本类型和引用类型](#基本类型和引用类型)
*   [常量和变量](#常量和变量)
*   [求值策略](#求值策略)
*   [Node.js 中的 module.exports 和 exports](#nodejs-中的-moduleexports-和-exports)
*   [更复杂的示例](#更复杂的示例)
*   [总结](#总结)
*   [参考资料](#参考资料)

## 前言

首先提出几个结论，后面将逐一解释和证实：

1.  变量（或常量）没有类型，有类型的是值。
2.  基本类型存储在栈内存中，有固定空间；

    引用类型存储在堆内存中，无固定空间，并且会在栈内存中保存一个指向该位置的指针。
3.  求值策略分为按值传递和按引用传递，而在 JavaScript 中均是按值传递的。

## 基本类型和引用类型

看一段简单的代码：

```js
const a = 100;

let b = 'Hello World';

let c = { key: 'value' };

const d = { foo: 'bar' };
```

此时的内存结构图：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  100                       |
      | 0x7fff74a13074 |                            |
      +---------------------------------------------+
      |       b        |                            |
stack |                |  'Hello World'             |
      | 0x7fffc8666f54 |                            |
      +---------------------------------------------+
      |       c        |                            |
      |                |  pointer => 0x7fff3827db64 +-----+
      | 0x7fffd66b3214 |                            |     |
      +---------------------------------------------+     |
      |       d        |                            |     |
      |                |  pointer => 0x7fffa19a9c94 +--+  |
      | 0x7ffc2766ebc4 |                            |  |  |
      +----------------+----------------------------+  |  |
                                                       |  |
            +------------------------------------------+  |
            |                                             |
      +-----v----------+----------------------------+     |
      |                |                            |     |
 heap | 0x7fffa19a9c94 |  { foo: 'bar' }            |     |
      |                |                            |     |
      +---------------------------------------------+     |
      |                |                            |     |
      | 0x7fff3827db64 |  { key: 'value' }          |     |
      |                |                            |     |
      +-----^----------+----------------------------+     |
            |                                             |
            +---------------------------------------------+
```

如图所示，十六进制的内存地址是给计算机看的，而变量或常量的名称（a, b, c, d）是给人类看的，实际上只是内存地址的一个别名而已，因此变量或常量并没有类型。

而变量（或常量）中保存的值即内存中存储的内容才有类型之分，比如图中：

*   `100`, `'Hello World'` 存储在栈（stack）中，它们是基本类型。

*   `{ foo: 'bar' }` 和 `{ key: 'value' }` 存储在堆（heap）中，它们是引用类型，并且分别在栈内存中存储了一个指针 `pointer`，指针指向它们所在的堆内存地址。

> 在 JavaScript 中，字符串、数值、布尔值、null 和 undefined 为基本类型，对象和函数等属于引用类型。

## 常量和变量

理解了前面的内存结构图后，接下来探讨一下 JavaScript 中的常量和变量。

前面的代码中 a 和 d 使用 const 关键字声明为常量，b 和 c 使用 let 关键字声明为变量。

分别尝试对 a, b, c, d 进行修改：
```js
a = 200; // TypeError: Assignment to constant variable.
```
```js
b = 'Hello JavaScript';
```
```js
c = { name: 'Tom' };
```
```js
d = {}; // TypeError: Assignment to constant variable.
```

变量 b 和 c 被修改了，而对常量 a 和 d 修改会报错。

再尝试对常量 d 的 foo 属性进行修改：

```js
d.foo = 'something';
```

惊奇地发现，竟然修改成功了！！

此时的内存结构图：

```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  100                       |
      | 0x7fff74a13074 |                            |
      +---------------------------------------------+
      |       b        |                            |
stack |                |  'Hello JavaScript'        |
      | 0x7fffc8666f54 |                            |
      +---------------------------------------------+
      |       c        |                            |
      |                |  pointer => 0x7ffedbdbb7a4 +-----+
      | 0x7fffd66b3214 |                            |     |
      +---------------------------------------------+     |
      |       d        |                            |     |
      |                |  pointer => 0x7fffa19a9c94 +--+  |
      | 0x7ffc2766ebc4 |                            |  |  |
      +----------------+----------------------------+  |  |
                                                       |  |
            +------------------------------------------+  |
            |                                             |
      +-----v----------+----------------------------+     |
      |                |                            |     |
 heap | 0x7fffa19a9c94 |  { foo: 'something' }      |     |
      |                |                            |     |
      +---------------------------------------------+     |
      |                |                            |     |
      | 0x7fff3827db64 |  { key: 'value' }  --------+----------> 垃 圾 回 收
      |                |                            |     |
      +---------------------------------------------+     |
      |                |                            |     |
      | 0x7ffedbdbb7a4 |  { name: 'Tom' }           |     |
      |                |                            |     |
      +-----^----------+----------------------------+     |
            |                                             |
            +---------------------------------------------+
```

不是说 d 是常量吗？？？为什么能修改成功？？？

实际上，JavaScript 中的常量对于基本类型来说很好理解，比如这里的常量 a 无法通过重新赋值进行修改。

而对于引用类型的常量，比如这里的常量 d，上文解释过 d 是栈内存中的一段地址，这段地址所在的位置存储的是一个指针，
因为 d 是常量，因此其存储的指针不可修改，但是使用 `d.foo` 属性时，实际上操作的是堆内存中存储的数据，因此可以修改其属性的值。

而对于引用类型的变量，比如这里的变量 c，对 c 重新赋值进行修改时，实际上修改的是栈内存中的指针，因为新值 `{ name: 'Tom' }`
为引用类型存储在堆内存中，因此旧指针被修改为一个指向该堆内存地址的新指针，而之前的值 `{ key: 'value' }`
不再被任何地方引用到，因此会被垃圾回收机制处理掉。

假如将 c 的值修改为基本类型会发生什么呢？
```js
c = true;
```

此时的内存结构图：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  100                       |
      | 0x7fff74a13074 |                            |
      +---------------------------------------------+
      |       b        |                            |
stack |                |  'Hello JavaScript'        |
      | 0x7fffc8666f54 |                            |
      +---------------------------------------------+
      |       c        |                            |
      |                |  true                      |
      | 0x7fffd66b3214 |                            |
      +---------------------------------------------+
      |       d        |                            |
      |                |  pointer => 0x7fffa19a9c94 +--+
      | 0x7ffc2766ebc4 |                            |  |
      +----------------+----------------------------+  |
                                                       |
            +------------------------------------------+
            |
      +-----v----------+----------------------------+
      |                |                            |
 heap | 0x7fffa19a9c94 |  { foo: 'something' }      |
      |                |                            |
      +---------------------------------------------+
      |                |                            |
      | 0x7fff3827db64 |  { key: 'value' }  -------------------> 垃 圾 回 收
      |                |                            |
      +---------------------------------------------+
      |                |                            |
      | 0x7ffedbdbb7a4 |  { name: 'Tom' }   -------------------> 垃 圾 回 收
      |                |                            |
      +----------------+----------------------------+
```

此时变量 c 处存储的内容变成基本类型中的布尔值 true，而不再是一个指针，因此也不会再指向任何的堆内存地址，
而原来指向的堆内存地址中存储的 `{ name: 'Tome' }` 也会被垃圾回收机制处理掉。

## 求值策略

关于函数调用时实参和形参之间值的传递方式：

*   按值传递（call by value）：最常用的求值策略，函数的形参是被调用时所传实参的副本，修改形参的值并不会影响实参。

*   按引用传递（call by reference）：函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值。

文章开头说过一个结论：

> 在 JavaScript 中均是按值传递的。

如何去理解呢，首先看一个例子：

```js
const a = { foo: 'bar' };
function f(b) {
  // do something
}

f(a);
```

假如函数参数传递是按引用传递的，则函数调用后内存结构图应该为这样：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
stack |       b        |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
      +----------------+----------------------------+  |
                                                       |
            +------------------------------------------+
            |
      +-----v----------+----------------------------+
      |                |                            |
 heap | 0x7ffc7d2902c4 |  { foo: 'bar' }            |
      |                |                            |
      +----------------+----------------------------+
```

但是，在 JavaScript 中，函数调用后实际上的内存结构图是这样的：

```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
stack +---------------------------------------------+  |
      |       b        |                            |  |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffed7977474 |                            |  |
      +----------------+----------------------------+  |
                                                       |
            +------------------------------------------+
            |
      +-----v----------+----------------------------+
      |                |                            |
 heap | 0x7ffc7d2902c4 |  { foo: 'bar' }            |
      |                |                            |
      +----------------+----------------------------+
```
变量 a 中存储的值为一个指针，在传递过程中其拷贝了一下这个指针，并存储在栈内存中 b 处，
此时变量 b 只是变量 a 的一个副本，修改变量 b  的值并不会影响到 a。例如：

```js
const a = { foo: 'bar' };
function f(b) {
  b = { hello: 'world' };
  console.log(a); // { foo: 'bar' }
  console.log(b); // { hello: 'world' }
}

f(a);
```

此时的内存结构图为：

```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
stack +---------------------------------------------+  |
      |       b        |                            |  |
      |                |  pointer => 0x7ffca4482a24 +-----+
      | 0x7ffed7977474 |                            |  |  |
      +----------------+----------------------------+  |  |
                                                       |  |
            +------------------------------------------+  |
            |                                             |
      +-----v----------+----------------------------+     |
      |                |                            |     |
      | 0x7ffc7d2902c4 |  { foo: 'bar' }            |     |
      |                |                            |     |
 heap +---------------------------------------------+     |
      |                |                            |     |
      | 0x7ffca4482a24 |  { hello: 'world' }        |     |
      |                |                            |     |
      +-----^----------+----------------------------+     |
            |                                             |
            +---------------------------------------------+
```

是不是一目了然了。变量 b 存储的指针被修改了，指向了堆内存中的一个新的位置，而这一切对变量 a 并没有造成任何影响。

回到最初的状态，假如对 `b.foo` 进行修改会发生什么呢：

```js
const a = { foo: 'bar' };
function f(b) {
  b.foo = 'something';
  console.log(a); // { foo: 'something' }
  console.log(b); // { foo: 'something' }
}

f(a);
```

此时的内存结构图：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
stack +---------------------------------------------+  |
      |       b        |                            |  |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffed7977474 |                            |  |
      +----------------+----------------------------+  |
                                                       |
            +------------------------------------------+
            |
      +-----v----------+----------------------------+
      |                |                            |
 heap | 0x7ffc7d2902c4 |  { foo: 'something' }      |
      |                |                            |
      +----------------+----------------------------+
```

修改成功了！这是因为对 `b.foo` 进行操作实际上操作的是堆内存中的位置，因此堆内存中存储的数据被修改了，
而此时变量 a 和变量 b 所指向的堆内存位置还是一样的，因此变量 a 看起来也被 “修改” 了。

所以说 `在 JavaScript 中均是按值传递的。`

## Node.js 中的 `module.exports` 和 `exports`

```js
var _module = { _exports: {} };

// _exports 保存着 _module._exports 所保存的指针的一份拷贝
var _exports = _module._exports;

// 此时 _exports 和 _module._exports 各自保存的指针指向同一块内存地址
console.log(_exports === _module._exports); // true

_exports.foo = 'bar';
console.log(_exports);  // { foo: 'bar' }
console.log(_module);   // { _exports: { foo: 'bar' } }

// _exports 指向了一个新对象的内存地址
_exports = { hello: 'world' };
console.log(_exports);  // { hello: 'world' }
console.log(_module);   // { _exports: { foo: 'bar' } }

_module._exports = { it: 'works' };
console.log(_exports);  // { hello: 'world' }
console.log(_module);   // { _exports: { it: 'works' } }
```

JavaScript 变量之间赋值也是按值传递的，这段代码我就不画内存结构图了，搞懂了这一段代码就能理解 Node.js 中 `module.exports`
和 `exports` 的区别了，也就能理解为什么在 Node.js 中不能 `exports = { /* something */ }` 这样导出模块了。

## 更复杂的示例


```js
// 第一步
var a = { n: 1 };
var b = { n: 2 };

var c = a;
var d = c;

// 第二步
c.x = c = b;

console.log(a); // { n: 1, x: { n: 2 } }
console.log(b); // { n: 2 }
console.log(c); // { n: 2 }
console.log(d); // { n: 1, x: { n: 2 } }

console.log(c.x)  // undefined
console.log(d.x)  // { n: 2 }

// 第三步
c.n++

console.log(a); // { n: 1, x: { n: 3 } }
console.log(b); // { n: 3 }
console.log(c); // { n: 3 }
console.log(d); // { n: 1, x: { n: 3 } }
```

第一步结束后，内存结构图：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
stack +---------------------------------------------+  |
      |       b        |                            |  |
      |                |  pointer => 0x7ffca4482a24 +-----+
      | 0x7ffed7977474 |                            |  |  |
      +---------------------------------------------+  |  |
      |       c        |                            |  |  |
      |                |  pointer => 0x7ffc7d2902c4 +--+  |
      | 0x7ffcca1abb94 |                            |  |  |
      +---------------------------------------------+  |  |
      |       d        |                            |  |  |
      |                |  pointer => 0x7ffc7d2902c4 +--+  |
      | 0x7ffe1a84bce4 |                            |  |  |
      +----------------+----------------------------+  |  |
                                                       |  |
            +------------------------------------------+  |
            |                                             |
      +-----v----------+----------------------------+     |
      |                |                            |     |
      | 0x7ffc7d2902c4 |  { n: 1 }                  |     |
      |                |                            |     |
 heap +---------------------------------------------+     |
      |                |                            |     |
      | 0x7ffca4482a24 |  { n: 2 }                  |     |
      |                |                            |     |
      +-----^----------+----------------------------+     |
            |                                             |
            +---------------------------------------------+
```
第二步结束后，内存结构图：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
stack +---------------------------------------------+  |
      |       b        |                            |  |
      |                |  pointer => 0x7ffca4482a24 +-----+
      | 0x7ffed7977474 |                            |  |  |
      +---------------------------------------------+  |  |
      |       c        |                            |  |  |
      |                |  pointer => 0x7ffca4482a24 +-----+
      | 0x7ffcca1abb94 |                            |  |  |
      +---------------------------------------------+  |  |
      |       d        |                            |  |  |
      |                |  pointer => 0x7ffc7d2902c4 +--+  |
      | 0x7ffe1a84bce4 |                            |  |  |
      +----------------+----------------------------+  |  |
                                                       |  |
                                                       |  |
            +------------------------------------------+  |
            |                                             |
      +-----v----------+----------------------------+     |
      |                |  {                         |     |
      | 0x7ffc7d2902c4 |    n: 1,                   |     |
      |                |    x: <0x7ffca4482a24> ----------+
      |                |  }                         |     |
 heap +---------------------------------------------+     |
      |                |                            |     |
      | 0x7ffca4482a24 |  { n: 2 }                  |     |
      |                |                            |     |
      +-----^----------+----------------------------+     |
            |                                             |
            +---------------------------------------------+
```
调用 `c.x = c = b;` 的时候，这里有涉及到三个操作：c.x，c.x = c 和 c = b。其中优先级最高的是 c.x，其次是 c = b，最后是 c.x = c。

因此`c.x` 实际上操作的是 a, c, d 存储的指针指向的那一块内存地址。 通过
`c = b`，此时 b, c 存储的指针指向了同一块堆内存地址，c 存储的指针和 a, d 存储的指针指向的内存地址不再一样。

操作完成后，b, c, a.x, d.x 所存储的指针指向了同一块堆内存地址，那里存储的内容为 `{ n: 2 }`。因此：

第三步结束后，内存结构图：
```
          内 存 地 址             存 储 内 容
      +----------------+----------------------------+
      |       a        |                            |
      |                |  pointer => 0x7ffc7d2902c4 +--+
      | 0x7ffce2f40e64 |                            |  |
stack +---------------------------------------------+  |
      |       b        |                            |  |
      |                |  pointer => 0x7ffca4482a24 +-----+
      | 0x7ffed7977474 |                            |  |  |
      +---------------------------------------------+  |  |
      |       c        |                            |  |  |
      |                |  pointer => 0x7ffca4482a24 +-----+
      | 0x7ffcca1abb94 |                            |  |  |
      +---------------------------------------------+  |  |
      |       d        |                            |  |  |
      |                |  pointer => 0x7ffc7d2902c4 +--+  |
      | 0x7ffe1a84bce4 |                            |  |  |
      +----------------+----------------------------+  |  |
                                                       |  |
                                                       |  |
            +------------------------------------------+  |
            |                                             |
      +-----v----------+----------------------------+     |
      |                |  {                         |     |
      | 0x7ffc7d2902c4 |    n: 1,                   |     |
      |                |    x: <0x7ffca4482a24> ----------+
      |                |  }                         |     |
 heap +---------------------------------------------+     |
      |                |                            |     |
      | 0x7ffca4482a24 |  { n: 3 }                  |     |
      |                |                            |     |
      +-----^----------+----------------------------+     |
            |                                             |
            +---------------------------------------------+
```

## 总结

本文开头提出几个结论并且一一解释和证实，讲解了 JavaScript 中的引用类型涉及到的一些常用知识点。

*   第一小节解释了基本类型和引用类型的区别，并且读者需要明白变量并没有类型，变量只是内存地址的一个别名，
    内存地址上存储的内容才有类型。

*   第二小节解释了困扰了很多 ES6 初学者的问题，解释了为什么用 const 声明的对象的属性的值仍然可以被修改。

*   第三小节证实了 JavaScript 中的求值策略均是值传递，这需要和别的编程语言区分开来。

*   第四小节通过一段代码，简单演示了 Node.js 中 `module.exports` 和 `exports` 的区别，这也是常常给 Node.js
    初学者带来困扰的一个问题。

*   第五小节通过一个稍微复杂的实例，综合了本文涉及到的几个知识点。

通过这篇文章，希望各位能对 JavaScript 中的引用类型有个更深刻的理解。

## 参考资料

*   [在 Node.js 中看 Javascript 的引用](https://zhuanlan.zhihu.com/p/26128007)
*   [JS是按值传递还是按引用传递](http://www.jb51.net/article/60568.htm)

